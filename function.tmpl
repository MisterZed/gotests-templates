{{define "function"}}
{{- $f := .}}

func {{.TestName}}(t *testing.T) {
	testCases := []struct {
		description string

		{{- if .TestParameters}}
				// function parameters
			{{- range .TestParameters}}
				{{Param .}} {{.Type}}
			{{- end}}
		{{- end}}

			// expected results
		{{- range .TestResults}}
			expectedResult {{.Type}}
		{{- end}}
		{{- if .ReturnsError}}
			expectedError error
		{{- end}}
	}{
		// TODO: Add test cases here
	}

	for {{if (or .Subtests (not .IsNaked))}} _, tc := {{end}} range testCases {
        {{- if .Subtests }}t.Run(tc.description, func(t *testing.T) { {{- end -}}
			{{with .Receiver}}
				{{- if .IsStruct}}
					var env struct {
						{{- if .Fields}}
							//TODO: Add/remove injected dependencies here
							{{- range .Fields}}
								{{Field .}} {{.Type}}
							{{- end}}
						{{- end}}

						{{printf "%q" .Type.Value}} {{.Type}}
					}
					testloader.MustStart(t, &env)
				{{- end}}
			{{- end}}

			{{with .Receiver}}
				{{- if .IsStruct}}
				/*
					ctrl := gomock.NewController(t)
					defer ctrl.Finish()

					{{Receiver .}} := {{if .Type.IsStar}}&{{end}}{{.Type.Value}}{
					{{- range .Fields}}
						{{.Name}}: tc.state.{{Field .}},
					{{- end}}
					}
				*/
				{{- end}}
			{{- end}}

            {{if .OnlyReturnsError}}
                err := {{template "call" $f}}
            {{- else}}
                {{template "results" $f}} {{template "call" $f}}
            {{- end}}

			{{range .TestResults}}
				{{- if .IsWriter}}
                    assert.Equal(t, {{Param .}}.String(), tc.expectedResult)
				{{- else if .IsBasicType}}
					assert.Equal(t, result, tc.expectedResult)
				{{- else}}
					assert.Equal(t, result, tc.expectedResult)
				{{- end}}
			{{- end}}
			{{- if .ReturnsError}}
				if tc.expectedError == nil {
					assert.NoError(t, err)
				} else {
					assert.Contains(t, err.Error(), tc.expectedError.Error())
				}
			{{- end}}
		{{- if .Subtests }} }) {{- end -}}
	}
}

{{end}}
